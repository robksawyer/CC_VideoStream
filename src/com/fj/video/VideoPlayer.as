package com.fj.video {		/* ****************************************************** *\	* 	CHINCHILLAX FLASH VIDEO PLAYER	* 		* 	Preview/Generator:	* 	  http://www.chinchillax.com/shop/videostream/	* 		* 	Source/Code:	* 	  https://github.com/robksawyer/CC_VideoStream	* 		* 	Optimized and Updated To Work With VJ Applications:	* 		Rob Sawyer	*			http://www.chinchillax.com/team	*				*	Original Author:	* 	  Martin Bommeli	* 	  http://www.flashjunior.ch	* 		* 	Original graphics and some part of codes:	* 	  Abdulhalim Kara	* 	  http://www.abdulhalimkara.com/	* 		* 	Original graphics and some part of codes:	* 	  Abdulhalim Kara	* 	  http://www.abdulhalimkara.com/	*	\* ****************************************************** */	import de.derhess.video.youtube.YouTubeError;	import flash.events.SecurityErrorEvent;	import flash.events.AsyncErrorEvent;	import de.derhess.video.youtube.YouTubePlayingState;	import de.derhess.video.youtube.YouTubeVideoQuality;	import de.derhess.video.youtube.YouTubeEvent;	import de.derhess.video.youtube.FlashYouTube;	import com.fj.utils.StopDragButton;	import flash.display.Loader;	import flash.net.URLRequest;	import com.demonsters.debugger.MonsterDebugger;	import flash.display.MovieClip;	import flash.text.TextField;	import flash.display.Stage;	import flash.events.Event;	import flash.events.FullScreenEvent;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.events.NetStatusEvent;	import flash.events.TimerEvent;	import flash.media.SoundTransform;	import flash.media.Video;	import flash.net.NetConnection;	import flash.net.NetStream;	import flash.net.SharedObject;	import flash.utils.Timer;	import flash.geom.Rectangle		import com.greensock.*;	import com.greensock.easing.*;	import com.greensock.plugins.*;	TweenPlugin.activate([TintPlugin]);			public class VideoPlayer extends MovieClip{				//		//STATIC VARS		//		public static var STAGE:Stage;		//		//INTERFACE ELEMENTS		//		private var CTRL_BAR:MovieClip;		private var CTRL_BAR_BG:MovieClip;		private var FULLSCREEN_BTN:MovieClip;		private var VOLUME_BAR:MovieClip;		private var VOLUME_SCRUBBER_CONTAINER:MovieClip;		private var VOLUME_SCRUBBER:MovieClip;		private var VOLUME_SCRUBBER_SC:MovieClip;		private var VOLUME_BAR_BG:MovieClip;		private var SPEAKER:MovieClip;		private var VOLUME_HIT_AREA:MovieClip;		private var TIME_CONTAINER:MovieClip;		private var DURATION_TF:TextField;		private var TIME_TF:TextField;		private var WELCOME_PLAY_BTN:MovieClip;		private var PLAY_BTN:MovieClip;		private var PAUSE_BTN:MovieClip;		private var VIDEO_LOADER:MovieClip;		private var VIDEO_SCRUBBER:MovieClip;		private var VIDEO_SCRUBBER_SC:MovieClip;		private var VIDEO_SEEK_BAR_BG:MovieClip;		private var VIDEO_SEEK_BAR_HIT:MovieClip;		private var VIDEO_SEEK_BAR:MovieClip;		private var VIDEO_TRIM_IN_HANDLE:MovieClip;		private var VIDEO_TRIM_OUT_HANDLE:MovieClip;		private var VIDEO_TRIM_BAR_VALUES:MovieClip;		private var ERROR_TF:TextField;		//		//PRIVATE VARS		//		private var seekbarWidth:uint;		private var volumebarWidth:uint;		private var stageWidth:uint;		private var stageHeight:uint;				private var sharedObj:SharedObject;		private var soundtransform:SoundTransform;				private var stopScrubDrag:StopDragButton;		private var stopVScrubDrag:StopDragButton;				private var lastState:String;				private var connection:NetConnection;		private var stream:NetStream;				private var loader:MovieClip;		private var ctrlBar:MovieClip;				private var welcome:MovieClip;						private var autoHideTimer:Timer;				private var buttomSpacing:Number;				private var VIDEO_SRC:String;		private var VIDEO_TYPE: String;		private var YouTubePlayer : FlashYouTube;		//private var vimeoPlayer : VimeoPlayer;		private var trimPointsInitialized:Boolean = false;		private var theInPoint:Number = 0; /// sets default end point to 0		private var theOutPoint:Number = 0;		private var videoDuration:Number = 0;		//		//PUBLIC VARS		//		public var currentState:String;		public var currentVideo:String;				public var video_mc:MovieClip; //THE VIDEO PLAYER HOLDER (ACCESS POINT)		private var video:Video;				public var videoTime:Number = 0;		public var theScrubPoint:Number;		//		//GETTERS & SETTERS		//				/**		*		* Returns the interface location of the playhead		* @param void		* @return Number		**/		public function get playheadLocation():Number		{			return VIDEO_SEEK_BAR.width;		}		/**		* Sets the duration of the video clip and updates the interface.		*/		private function get duration():Number{ return videoDuration; }				private function set duration(value:Number):void{			var minute:uint = getMins(value);			var second:uint = getSecs(value);						DURATION_TF.text = "";			if(minute < 10)			{				DURATION_TF.text = "0";			}			DURATION_TF.appendText(minute.toString() + ":");						if(second < 10)			{				DURATION_TF.appendText("0");			}			DURATION_TF.appendText(second.toString());						videoDuration = value;		}				/**		* Sets the current playhead time val		*/		public function set time(value:Number):void		{			value = value > duration ? duration : value;						var minute:uint = getMins(value);			var second:uint = getSecs(value);			MonsterDebugger.trace(this, "Setting time: " + minute + ":" + second);						TIME_TF.text = "";			if(minute < 10){				TIME_TF.text = "0";			}			TIME_TF.appendText(minute.toString() + ":");						if(second < 10){				TIME_TF.appendText("0");			}			TIME_TF.appendText(second.toString());						videoTime = value;		}		public function get time():Number		{			return videoTime;		}		/**		 * Sets the URL for which to use to load the video.		 */		public function set url( value:String ):void 		{			this.VIDEO_SRC = value;			init();		}				/**		 * Returns the URL of the current video.		 */		public function get url():String { return this.VIDEO_SRC; }		/**		 * Sets the URL for which to use to load the video.		 */		public function set type( value:String ):void 		{			if(value == "vimeo")			{				MonsterDebugger.trace(this, "The Vimeo player is no longer supported by this class.");				return;			}			this.VIDEO_TYPE = value;		}				/**		 * Returns the URL of the current video.		 */		public function get type():String { return this.VIDEO_TYPE; }		/**		* Helper method to set the trim in point		* @param val:Number (0-1) The value will be coming from VJ app. It's a float from 0-1.		* @return void		*/		public function set trimInPoint(val:Number):void		{			var durationSeconds:uint = getSecs(duration);			var tInPoint:Number = roundTo((val - 0) * durationSeconds, 1);			if (tInPoint > trimOutPoint)			{				tInPoint = roundTo((trimOutPoint - 0.1), 1);				val = tInPoint;			}			MonsterDebugger.trace(this, "tInPoint: " + tInPoint, "Trim Debug");			theInPoint = tInPoint;			updateTrimHandleLocations();						MonsterDebugger.trace(this, "trimInPoint(): " + theInPoint, "Trim Debug");		}		public function get trimInPoint():Number		{			return theInPoint;		}				/**		* Helper method to set the trim out point		* @param val:Number (0-1) The value will be coming from VJ app. It's a float from 0-1.		* @return void		* TODO: Get the trim points to work properly.		*/		public function set trimOutPoint(val:Number):void		{			var durationSeconds:uint = getSecs(duration);			MonsterDebugger.trace(this, "Duration (secs): " + durationSeconds, "Trim Debug");			var relVal:Number = roundTo((val - 0) * durationSeconds, 1);			if(relVal < durationSeconds)			{				theOutPoint =  relVal;			}			else			{				theOutPoint = durationSeconds;			}						updateTrimHandleLocations();			MonsterDebugger.trace(this,  "theOutPoint(): " + theOutPoint, "Trim Debug");		}		public function get trimOutPoint():Number		{			return theOutPoint;		}		/**		* Sets the point at which the player should play from. This fires when the VJ App scrubber is used.		* @param val:Number 		* @return void		*/		public function set scrubPoint(val:Number):void		{			MonsterDebugger.trace(this, "scrubPoint(" + val + ")");			MonsterDebugger.trace(this, "Current Duration: " + duration);			var durationSeconds:uint = getSecs(duration);			//var theRealPosition = Math.round( ((val - 0) * durationSeconds) / 100 );			var theRealPosition = (val - 0) * durationSeconds;						lastState = currentState;			if(VIDEO_TYPE == "youtube") {				YouTubePlayer.pauseVideo();			}else if(VIDEO_TYPE == "vimeo"){				//DEPRECATED				//vimeoPlayer.pause();			}else{				stream.pause();			}			hardSeekVideo(durationSeconds, true);		}		/**		*		* Sets the video volume		*		**/		public function set volume(val:Number):void		{			if(val < 0) 			{				val = 0;			}			else if(val > 1) 			{				val = 1;			}			setVolume(val);						//TODO: Verify this works.			VOLUME_SCRUBBER.x = val * volumebarWidth;			updateVolume();		}		/**		* Entry point		* @param videoSrc:String The video source to load.		* @param videoType:String The type of video to load. Types include: "youtube" and "normal"		* @return void		*/		public function VideoPlayer(videoSrc:String, videoType:String)		{			// Start the MonsterDebugger			MonsterDebugger.initialize(this);			MonsterDebugger.enabled = true;			MonsterDebugger.trace(this, "VideoPlayer - init");						ctrlBar = this["controllerbar_mc"];			loader = this["loader_mc"];			welcome = this["welcome_mc"];						this.VIDEO_SRC = videoSrc;			this.VIDEO_TYPE = videoType;						//stopScrubDrag = new StopDragButton();			//stopVScrubDrag = new StopDragButton();						removeChild(loader); //Remove the loader						sharedObj = SharedObject.getLocal("osvideoplayervolumelevel");						hideErrorTxt(); //Hide any error text						init();						if(CCVideoPlayer.imgSrc != "")			{				var imageLoader:Loader = new Loader();				var imageRequest:URLRequest = new URLRequest(String(CCVideoPlayer.imgSrc));								imageLoader.contentLoaderInfo.addEventListener(Event.COMPLETE, function(evt:Event):void				{					try					{						welcome.img_mc.addChild(imageLoader.content);					}					catch(e)					{						welcome.img_mc.addChild(imageLoader);					}										stageResize();				});								imageLoader.load(imageRequest);			}						setCTRLButton(WELCOME_PLAY_BTN, handleBigPlayClick);		}				/**		* Initializes the player 		* @param void		* @return void		*/		public function init():void		{			STAGE.addEventListener(KeyboardEvent.KEY_DOWN, handleKeyDown);			addEventListener(Event.ADDED_TO_STAGE, handleAddedToStage);			STAGE.addEventListener(FullScreenEvent.FULL_SCREEN, handleFullScreenEvent);			STAGE.addEventListener(Event.RESIZE, stageResize);						//			//Config the interface references			//			configureInterfaceReferences();			//			//Hide the trim bar values			//			VIDEO_TRIM_BAR_VALUES.visible = false;			if(CCVideoPlayer.autohide == "true")			{				STAGE.addEventListener(Event.MOUSE_LEAVE, handleMouseLeave);								STAGE.addEventListener(MouseEvent.MOUSE_MOVE, handleMouseMove);								autoHideTimer = new Timer(3000);				autoHideTimer.addEventListener(TimerEvent.TIMER, handleAutoHideTimerTick);								ctrlBar.y = STAGE.stageHeight+20;								buttomSpacing = 0;			}			else			{				buttomSpacing = CTRL_BAR_BG.height;			}						//TweenLite.to(VIDEO_SEEK_BAR, 0, {tint:CCVideoPlayer.seekbarColor});			//TweenLite.to(VOLUME_BAR, 0, {tint:CCVideoPlayer.seekbarColor});						TweenLite.to(VIDEO_LOADER, 0, {tint:CCVideoPlayer.loadingbarColor});						TweenLite.to(VIDEO_SEEK_BAR_BG, 0, {tint:CCVideoPlayer.seekbarbgColor});			TweenLite.to(VOLUME_BAR_BG, 0, {tint:CCVideoPlayer.seekbarbgColor});						TweenLite.to(TIME_CONTAINER.bg, 0, {tint:CCVideoPlayer.seekbarbgColor});						TweenLite.to(TIME_TF, 0, {tint:CCVideoPlayer.textColor});			TweenLite.to(DURATION_TF, 0, {tint:CCVideoPlayer.textColor});			TweenLite.to(TIME_CONTAINER.div, 0, {tint:CCVideoPlayer.textColor});									if(CCVideoPlayer.fullscreenMode == "false")			{				FULLSCREEN_BTN.visible = false;				FULLSCREEN_BTN.width = 0;			}			else			{				setCTRLButton(FULLSCREEN_BTN, switchFullScreenMode);			}							if(VIDEO_TYPE == "youtube")			{				YouTubePlayer = new FlashYouTube();				YouTubePlayer.addEventListener(YouTubeEvent.PLAYER_LOADED, youtubeHandlePlayerLoaded);				YouTubePlayer.addEventListener(YouTubeEvent.STATUS, youtubeHandlePlayingState);				YouTubePlayer.addEventListener(YouTubeEvent.ERROR, youtubeHandleError);				video_mc.addChild(YouTubePlayer);							}			else if(VIDEO_TYPE == "vimeo")			{				//DEPRECATED: This is now handled by the moogaloop.VimeoPlayer class.				//vimeoPlayer = new VimeoPlayer(VIDEO_SRC, 200, 200, 1);				//video_mc.addChild(vimeoPlayer);			}			else			{				soundtransform = new SoundTransform();				connection = new NetConnection();				connection.addEventListener(NetStatusEvent.NET_STATUS, conNetStatusHandler);				connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler)				connection.connect(null);			}									VIDEO_SCRUBBER.lockCenter = false;			VIDEO_SCRUBBER.dragBounds = new Rectangle(0, 0, VIDEO_SEEK_BAR_BG.width-VIDEO_SCRUBBER.width, 0);						VIDEO_SCRUBBER.stopDragBtn = new StopDragButton().registerDragBtn(VIDEO_SCRUBBER);						VOLUME_SCRUBBER.sc = VOLUME_SCRUBBER_SC;						VOLUME_SCRUBBER.lockCenter = false;			VOLUME_SCRUBBER.dragBounds = new Rectangle(0, 0, VOLUME_BAR_BG.width-VOLUME_SCRUBBER.width, 0);						VOLUME_SCRUBBER.stopDragBtn = new StopDragButton().registerDragBtn(VOLUME_SCRUBBER);									time = 0;			duration = 0;			VIDEO_SCRUBBER.x = VIDEO_SCRUBBER_SC.x;			VIDEO_SEEK_BAR.width = 0.1;			VIDEO_LOADER.width = 0.1;						PAUSE_BTN.visible = false;			disableCTRLButton(PAUSE_BTN, pauseVideo);			disableCTRLButton(PLAY_BTN, playVideo);						disableCTRLButton(VIDEO_SCRUBBER, null, changeScrubState);			disableCTRLButton(VOLUME_SCRUBBER, null, changeVolumeScrubState);						if(SPEAKER)			{				disableCTRLButton(SPEAKER, toggleMute);			}						stageResize();			updateCTRLButtonsPosition();		}		/**		*		* Resets the player after a new video source is loaded		* @param		* @return		*		**/		public function resetPlayer(videoSrc:String):void		{			MonsterDebugger.trace(this, "Resetting player...", "RESET");			//Set the new video source			this.VIDEO_SRC = videoSrc;			if(VIDEO_TYPE == "youtube") 			{				if(YouTubePlayer)				{					YouTubePlayer.stopVideo();					YouTubePlayer.cueVideoById(VIDEO_SRC,0,YouTubeVideoQuality.DEFAULT);					//TODO:Figure out why this doesn't work.					//YouTubePlayer.loadVideoByUrl(VIDEO_SRC,0);					/*initScrubbing();					stageResize();					if(CCVideoPlayer.autoplay == "true"){ 						playVideo();					}*/				}				else				{					MonsterDebugger.trace(this, "There was an issue finding the YouTubePlayer instance.", "ERROR");				}			}			else if(VIDEO_TYPE == "vimeo")			{				//DEPRECATED 			}			else			{				stream.close();				//TODO: Be sure to reinitialize this				connection.connect(null);			}		}		/**		*		* Add easy references to the interface elements		* @param void		* @return void		*		**/		private function configureInterfaceReferences():void		{			CTRL_BAR = ctrlBar;			CTRL_BAR_BG = ctrlBar.bg_mc;			FULLSCREEN_BTN = ctrlBar.fullscreen_btn;			VOLUME_BAR = ctrlBar.bar_volume_mc.bar_mc;			VOLUME_SCRUBBER_CONTAINER = ctrlBar.bar_volume_mc;			VOLUME_SCRUBBER = ctrlBar.bar_volume_mc.scrub_mc;			VOLUME_SCRUBBER_SC = ctrlBar.bar_volume_mc.sc_mc;			VOLUME_HIT_AREA = ctrlBar.bar_volume_mc.hit_mc;			VOLUME_BAR_BG = ctrlBar.bar_volume_mc.bg_mc;			SPEAKER = ctrlBar.bar_volume_mc.speaker_mc;			TIME_CONTAINER = ctrlBar.time_mc;			DURATION_TF = ctrlBar.time_mc.duration_txt;			TIME_TF = ctrlBar.time_mc.time_txt;			WELCOME_PLAY_BTN = welcome.play_btn;			PLAY_BTN = ctrlBar.play_btn;			PAUSE_BTN = ctrlBar.pause_btn;			VIDEO_LOADER = ctrlBar.bar_seek_mc.bar_loader_mc;			VIDEO_SCRUBBER = ctrlBar.bar_seek_mc.scrub_mc;			VIDEO_SCRUBBER_SC = ctrlBar.bar_seek_mc.sc_mc;			VIDEO_SEEK_BAR_HIT = ctrlBar.bar_seek_mc.hit_mc;			VIDEO_SEEK_BAR_BG = ctrlBar.bar_seek_mc.bg_mc;			VIDEO_SEEK_BAR = ctrlBar.bar_seek_mc.bar_mc;			VIDEO_TRIM_BAR_VALUES = this["trim_values_mc"];			VIDEO_TRIM_IN_HANDLE = ctrlBar.bar_seek_mc.trim_bar_handle_in_mc;			VIDEO_TRIM_OUT_HANDLE = ctrlBar.bar_seek_mc.trim_bar_handle_out_mc;			ERROR_TF = ctrlBar.errortxt_mc.txt;		}		/**		* Fired when the player is added to the stage.		* @param e:Event		* @return void		*/		private function handleAddedToStage(e:Event):void{			VOLUME_SCRUBBER.x = sharedObj.data.volume != undefined ? Number(VOLUME_SCRUBBER.sc.x + sharedObj.data.volume) : VOLUME_SCRUBBER.x;			VOLUME_SCRUBBER.x = VOLUME_SCRUBBER.x < VOLUME_SCRUBBER.sc.x ? VOLUME_SCRUBBER.sc.x : (VOLUME_SCRUBBER.x > VOLUME_SCRUBBER.sc.x + volumebarWidth ? VOLUME_SCRUBBER.sc.x + volumebarWidth : VOLUME_SCRUBBER.x);						addChildAt(welcome, getChildIndex(video_mc) + 1);						setCTRLButton(PLAY_BTN, playVideo);			setCTRLButton(VOLUME_SCRUBBER, null, changeVolumeScrubState);			if(SPEAKER){				setCTRLButton(SPEAKER, toggleMute);			}						VOLUME_HIT_AREA.addEventListener(MouseEvent.MOUSE_DOWN, startVScrubDragging);			VOLUME_HIT_AREA.buttonMode = true;						updateVolume();						if(CCVideoPlayer.autoplay == "true")			{				playVideo();			}		}		/**		* Initializes the trim in and out points		* @param void		* @return void		*		**/		public function initTrimPoints():void		{			MonsterDebugger.trace(this, "initTrimPoints()", "Trim Debug");			MonsterDebugger.trace(this, "Trim Out Point -> " + trimOutPoint , "Trim Debug");						var durationSeconds:uint = getSecs(duration);			if(!trimPointsInitialized && durationSeconds > 0)			{				trimPointsInitialized = true;				trimInPoint = 0; //beginning of clip				trimOutPoint = durationSeconds; //end of clip				//Set the out point				MonsterDebugger.trace(this, "Trim Out Point Set -> " + trimOutPoint , "Trim Debug");				//Set the in point				VIDEO_TRIM_IN_HANDLE.x = VIDEO_SCRUBBER_SC.x;				VIDEO_TRIM_OUT_HANDLE.x = VIDEO_SEEK_BAR_BG.width;								//Position the trim values				VIDEO_TRIM_BAR_VALUES.x = STAGE.stageWidth - (VIDEO_TRIM_BAR_VALUES.width + 20);				VIDEO_TRIM_BAR_VALUES.y = 20;//-(STAGE.stageHeight - ctrlBar.height + 25); 				MonsterDebugger.trace(this, "Trim Out Point Interface Location -> " + VIDEO_TRIM_OUT_HANDLE.x , "Trim Debug");				VIDEO_TRIM_BAR_VALUES.visible = true;			}		}		/**			* Updates the trim bar location		* @param void		* @return void		*/		private function updateTrimHandleLocations():void		{			var durationSeconds:uint = getSecs(duration);			var minPosX:uint = minSeekWidth();			var maxPosX:uint = maxSeekWidth();			//Update the in bar interface			VIDEO_TRIM_BAR_VALUES.in_txt.text = trimInPoint;			VIDEO_TRIM_IN_HANDLE.x = roundTo(((trimInPoint/durationSeconds) - 0) * maxPosX, 1);			//Update the out bar interface			VIDEO_TRIM_BAR_VALUES.out_txt.text = trimOutPoint;			VIDEO_TRIM_OUT_HANDLE.x = roundTo(((trimOutPoint/durationSeconds) - 0) * maxPosX, 1);			MonsterDebugger.trace(this,  "Interface Trim Out Point:" + VIDEO_TRIM_OUT_HANDLE.x, "Interface");			VIDEO_SEEK_BAR.x = VIDEO_TRIM_IN_HANDLE.x;						//Set the seek bar width			//VIDEO_SEEK_BAR.width = VIDEO_TRIM_OUT_HANDLE.x - VIDEO_TRIM_IN_HANDLE.x;			//Restart the video			//hardSeekVideo(trimInPoint);		}		/**		*		* Returns the maximum physical seek distance based on the interface elements.		* @param 		* @return uint		*		**/		private function maxSeekWidth():uint		{			//return uint(VIDEO_SEEK_BAR_HIT.width - ( VIDEO_SEEK_BAR_HIT.width  - VIDEO_TRIM_IN_HANDLE.x ));			MonsterDebugger.trace(this, "maxSeekWidth() -> " + seekbarWidth);			return seekbarWidth;		}		/**		*		* Returns the minimum physical seek distance based on the interface elements.		* @param 		* @return uint		*		**/		private function minSeekWidth():uint		{			MonsterDebugger.trace(this, "minSeekWidth() -> " + VIDEO_SEEK_BAR_HIT.x);			return VIDEO_SEEK_BAR_HIT.x;		}		/**		*		* Handle the mouse leaving the scrubber		* @param e:Event		* @return void		*		**/		private function handleMouseLeave(e:Event):void		{			MonsterDebugger.trace(this, "handleMouseLeave()");			if(ctrlBar.y < STAGE.stageHeight && !STAGE.getChildByName("stopDragButton"))			{				TweenLite.to(ctrlBar, 0.5, {y:STAGE.stageHeight+20, ease:Quad.easeOut});			}			autoHideTimer.stop();		}				/**		*		* Handle the mouse movement of scrubber		* @param e:MouseEvent		* @return void		*		**/		private function handleMouseMove(e:MouseEvent = null):void		{			//MonsterDebugger.trace(this, "handleMouseMove()");			autoHideTimer.stop();			autoHideTimer.start();			/*if(e)			{				MonsterDebugger.trace(this, e);			}*/						var endPos:uint = STAGE.stageHeight-CTRL_BAR_BG.height;			if(ctrlBar.y > endPos)			{				TweenLite.to(ctrlBar, 0.5, {y:endPos, ease:Quad.easeOut});			}		}				/**		*		* Handles hiding the controls from the Timer event.		* @param e:TimerEvent		* @return void		*		**/		private function handleAutoHideTimerTick(e:TimerEvent):void		{			MonsterDebugger.trace(this, "handleAutoHideTimerTick()");			if(ctrlBar.y < STAGE.stageHeight && !ctrlBar.hitTestPoint(STAGE.mouseX, STAGE.mouseY))			{				MonsterDebugger.trace(this, "handleAutoHideTimerTick IF");				TweenLite.to(ctrlBar, 0.5, { y:STAGE.stageHeight+20, ease:Quad.easeOut });			}		}				/**		*		* Handles mouse click to switch the stage to fullscreen mode		* @param e:MouseEvent		* @return void		*		**/		private function switchFullScreenMode(e:MouseEvent):void		{			if(STAGE.displayState == "normal")			{				STAGE.displayState = "fullScreen";			}			else			{				STAGE.displayState = "normal";			}			stageResize();		}		/**		*		* Handle the event to actually change the screen size		* @param e:FullScreenEvent		* @return void		*		**/		private function handleFullScreenEvent(e:FullScreenEvent):void		{			stageResize();		}				/**		*		* Handles when the big play button (Youtube one) is clicked		* @param e:MouseEvent		* @return void		**/		private function handleBigPlayClick(e:MouseEvent):void		{			PLAY_BTN.dispatchEvent(new MouseEvent(MouseEvent.CLICK));		}				/**		*		* Handles updating the loading bar based on how much of the video has loaded.		* @param e:Event		* @return void		*		**/		private var bytesL:*;		private var bytesT:*;		public function updateLoadingbar(e:Event = null):void		{			if(VIDEO_TYPE == "youtube")			{				bytesL = YouTubePlayer.getVideoBytesLoaded();				bytesT = YouTubePlayer.getVideoBytesTotal();			}			else if(VIDEO_TYPE == "vimeo") { /* DEPRECATED */ }			else			{				bytesL = stream.bytesLoaded;				bytesT = stream.bytesTotal;			}			VIDEO_LOADER.width = bytesL / bytesT * seekbarWidth;			VIDEO_SCRUBBER.dragBounds = new Rectangle(0, 0, VIDEO_SEEK_BAR_BG.width-VIDEO_SCRUBBER.width, 0); // (x=1, y=3, w=11, h=13)						if(bytesL >= bytesT){ removeEventListener(Event.ENTER_FRAME, updateLoadingbar); }		}				/**		*		* Updates the time in the interface.		* @param e:Event		* @return void		* 		**/		private function updateTime(e:Event):void{			MonsterDebugger.trace(this, "updateTime()", "Time");			if(trimOutPoint < getSecs(duration) || VIDEO_TRIM_IN_HANDLE.x > 0)			{				VIDEO_SEEK_BAR.width = (VIDEO_SCRUBBER.x - VIDEO_TRIM_IN_HANDLE.x) > 0 ? ((VIDEO_SCRUBBER.x - VIDEO_TRIM_IN_HANDLE.x) <= VIDEO_TRIM_OUT_HANDLE.x ? (VIDEO_SCRUBBER.x - VIDEO_TRIM_IN_HANDLE.x) : VIDEO_TRIM_OUT_HANDLE.x) : 0.1;				time = (VIDEO_TRIM_OUT_HANDLE.x / VIDEO_SEEK_BAR.width) * duration;			}			else			{				VIDEO_SEEK_BAR.width = (VIDEO_SCRUBBER.x - VIDEO_SCRUBBER_SC.x) > 0 ? ((VIDEO_SCRUBBER.x - VIDEO_SCRUBBER_SC.x) <= seekbarWidth ? (VIDEO_SCRUBBER.x - VIDEO_SCRUBBER_SC.x) : seekbarWidth) : 0.1;				time = (VIDEO_SEEK_BAR.width / seekbarWidth) * duration;			}			MonsterDebugger.trace(this, "Duration: " + duration + " / Time: " + time, "Time");		}				/**		*		* Handles a STAGE_RESIZE event.		* @param e:Event		* @return void		* 		**/		private function stageResize(e:Event=null):void		{			stageWidth = STAGE.stageWidth;			stageHeight = STAGE.stageHeight;						if(VIDEO_TYPE == "youtube")			{				YouTubePlayer.setSize(stageWidth, stageHeight-buttomSpacing);							}			else if(VIDEO_TYPE == "vimeo")			{				//vimeoPlayer.setSize(stageWidth, stageHeight-buttomSpacing);						}			else			{				scaleMCtoMax(video_mc);				scaleMCtoMax(welcome.img_mc);			}						ERROR_TF.width = stageWidth;						updateCTRLButtonsPosition();						if(CCVideoPlayer.autohide == "true")			{				if(ctrlBar.y > STAGE.stageHeight-CTRL_BAR_BG.height)				{					ctrlBar.y = STAGE.stageHeight+20;				}				else				{					ctrlBar.y = stageHeight - CTRL_BAR_BG.height;				}							}			else			{				ctrlBar.y = stageHeight - CTRL_BAR_BG.height;			}						WELCOME_PLAY_BTN.x = Math.round(STAGE.stageWidth / 2);			WELCOME_PLAY_BTN.y = Math.round((STAGE.stageHeight-buttomSpacing) / 2);				loader.x = Math.round(STAGE.stageWidth / 2);			loader.y = Math.round((STAGE.stageHeight-buttomSpacing) / 2);						updateLoadingbar();		}				/**		*		* Updates interface control button position		* @param void		* @return void		*		**/		private function updateCTRLButtonsPosition():void		{			var itemMargin:uint = 10;						if(CCVideoPlayer.fullscreenMode == "false")			{				VOLUME_SCRUBBER_CONTAINER.x = stageWidth - VOLUME_BAR_BG.width - itemMargin;			}			else			{				FULLSCREEN_BTN.x = stageWidth - FULLSCREEN_BTN.width - itemMargin;					VOLUME_SCRUBBER_CONTAINER.x	= FULLSCREEN_BTN.x - VOLUME_BAR_BG.width - itemMargin;			}						VOLUME_SCRUBBER.x = VOLUME_SCRUBBER_SC.x + int(VOLUME_SCRUBBER.x - VOLUME_SCRUBBER_SC.x);						TIME_CONTAINER.x	= VOLUME_SCRUBBER_CONTAINER.x - TIME_CONTAINER.width - itemMargin;						VIDEO_SEEK_BAR_BG.width = TIME_CONTAINER.x - ctrlBar.bar_seek_mc.x - itemMargin;			VIDEO_SEEK_BAR_HIT.width = VIDEO_SEEK_BAR_BG.width - 4;						CTRL_BAR_BG.width = stageWidth;					if(TIME_CONTAINER.x < PAUSE_BTN.x+PAUSE_BTN.width)			{				TIME_CONTAINER.visible = ctrlBar.bar_seek_mc.visible = false;			}			else			{				TIME_CONTAINER.visible = ctrlBar.bar_seek_mc.visible = true;			}									if(VOLUME_SCRUBBER_CONTAINER.x < PAUSE_BTN.x+PAUSE_BTN.width)			{				VOLUME_SCRUBBER_CONTAINER.visible = false;			}			else			{			 	ctrlBar.bar_volume_mc.visible = true;			}			 				if(FULLSCREEN_BTN.x < PAUSE_BTN.x+PAUSE_BTN.width)			{				FULLSCREEN_BTN.visible = false;			}			else			{				FULLSCREEN_BTN.visible = true;			}						seekbarWidth = VIDEO_SEEK_BAR_HIT.width;			volumebarWidth = VOLUME_HIT_AREA.width;			updateTrimHandleLocations(); 		}		/**		*		* Scales the container to the stage dimensions		* @param mc:MovieClip		* @return void		* 		**/		private function scaleMCtoMax(mc:MovieClip):void		{			mc.height = stageHeight-buttomSpacing;			mc.scaleX = mc.scaleY;						if(mc.width > stageWidth)			{				mc.width = stageWidth;				mc.scaleY = mc.scaleX;			}						mc.x = (stageWidth - mc.width) / 2;			mc.y = ((stageHeight- buttomSpacing) - mc.height) / 2;		}				/**		*		* Handles setting video meta data 		* @param info:Object Video info object		* @return void		*		**/		private function metaDataHandler(info:Object):void		{			duration = info.duration;			video.width = info.width;			video.height = info.height;			initScrubbing();		}				/**		*		* Initialize the scrub bar		* @param void		* @return void		* 		**/		private function initScrubbing():void		{			setCTRLButton(VIDEO_SCRUBBER, null, changeScrubState);						addEventListener(Event.ENTER_FRAME, updateTime);			addEventListener(Event.ENTER_FRAME, updateScrub);			VIDEO_SEEK_BAR_HIT.addEventListener(MouseEvent.MOUSE_DOWN, startScrubDragging);			VIDEO_SEEK_BAR_HIT.buttonMode = true;						stageResize();		}				/**		* @param e:NetStatusEvent		* TODO: Figure out if this is the best loading method.		*/		private function conNetStatusHandler(e:NetStatusEvent):void		{			if(e.info.code == "NetConnection.Connect.Success")			{				var clientObj:Object = new Object();				clientObj.onMetaData = metaDataHandler;				//clientObj.onCuePoint = cuePointHandler;								stream = new NetStream(connection);				stream.bufferTime = 5;				stream.client = clientObj;				stream.checkPolicyFile = true;								video = new Video();				video.smoothing = true;				video_mc.addChild(video);				video.attachNetStream(stream);								stageResize();								stream.addEventListener(NetStatusEvent.NET_STATUS, strNetStatusHandler);				stream.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);			}		}				/**		* @param e:NetStatusEvent		*/		private function strNetStatusHandler(e:NetStatusEvent):void		{			var code:String = e.info.code;				if(code == "NetStream.Play.StreamNotFound")			{				showError("Stream not found: " + VIDEO_SRC);			} 			else if(code == "NetStream.Play.Start")			{				addEventListener(Event.ENTER_FRAME, updateLoadingbar);				if(!contains(loader)){addChild(loader);}				setPlayedState();			} 			else if(code == "NetStream.Play.Stop")			{				if(CCVideoPlayer.videoLoop == "false")				{					if(lastState == null)					{						if (!contains(welcome))						{							addChildAt(welcome, getChildIndex(video_mc) + 1);							stream.seek(0);							pauseVideo();						}					}				}				else				{					stream.seek(0);					//pauseVideo();				}			} 			else if(code == "NetStream.Pause.Notify")			{				setPausedState();			} 			else if(code == "NetStream.Unpause.Notify")			{				setPlayedState();			} 			else if(code == "NetStream.Buffer.Full" || code == "NetStream.Buffer.Flush")			{				stageResize();				if(contains(loader)){ removeChild(loader); }			}		}				/**			* @param e:KeyboardEvent		*/		private function handleKeyDown(e:KeyboardEvent):void		{			if(STAGE.getChildByName("stopDragButton") || STAGE.displayState == "fullScreen") return;						if(e.keyCode == 32){				if(currentState == "playing")				{					pauseVideo();				}				else				{					playVideo();				}			}		}				/**		*		* Handles playing the video when the interface button is pressed.		* @param e:MouseEvent		* @return void		*		**/		public function playVideo(e:MouseEvent = null):void		{			MonsterDebugger.trace(this, "playVideo()");			removeWelcome();						if(VIDEO_TYPE == "youtube")			{				setPlayedState();								if(!currentVideo)				{					YouTubePlayer.playVideo();					return;				}							}else if(VIDEO_TYPE == "vimeo")			{				//			}			else			{				if(!currentVideo)				{					stream.play(currentVideo = VIDEO_SRC);					return;				}											setPlayedState();								if(stream.time >= duration - 1){ stream.seek(0); }								stream.resume();			}		}				/**		* Handles pausing the video when the interface button is pressed.		* @param e:MouseEvent		*/		public function pauseVideo(e:MouseEvent = null):void		{			MonsterDebugger.trace(this, "pauseVideo()");			setPausedState();			if(VIDEO_TYPE == "youtube")			{				YouTubePlayer.pauseVideo();			}			else if(VIDEO_TYPE == "vimeo")			{				//vimeoPlayer.pause();			}			else			{				stream.pause();			}		}				/**		* Seeks to a specific location in the video when the interface button is dragged.		*	@param e:MouseEvent		* @return void		**/		private function seekVideo(e:MouseEvent):void		{			if(duration > 0){				var newSeek:* = Math.min(duration - 1, (VIDEO_SEEK_BAR.width / seekbarWidth) * duration);				if(VIDEO_TYPE == "youtube") 				{					YouTubePlayer.seekTo(newSeek);				}				else if(VIDEO_TYPE == "vimeo")				{					//DEPRECATED					//vimeoPlayer.seekTo(newSeek);				}				else				{					stream.seek(newSeek);				}			}		}		/**		*		* Helper method to set the playhead at a certain position		* @param secs:Number The time in the video to set the playhead at.		* @param allowSeekAhead:Boolean		* @return void		* 		**/		public function hardSeekVideo(secs:Number = 0.0, allowSeekAhead:Boolean = false):void		{			MonsterDebugger.trace(this, "hardSeekVideo(" + secs + ", " + allowSeekAhead + ")");			if(secs > 0){				//var newSeek:* = Math.min(duration - 1, (VIDEO_SEEK_BAR.width / seekbarWidth) * duration);				if(VIDEO_TYPE == "youtube") 				{					YouTubePlayer.seekTo(secs, true);				}				else if(VIDEO_TYPE == "vimeo")				{					//DEPRECATED					//vimeoPlayer.seekTo(secs);				}				else				{					//TODO: Check to make sure secs shouldn't be here.					stream.seek(secs);				}			}		}				/**		*		* Sets the played state of the video in the interface.		* @param		* @return void		*		**/		private function setPlayedState():void		{			currentState = "playing";			PLAY_BTN.visible = false;			PAUSE_BTN.visible = true;			disableCTRLButton(PLAY_BTN, playVideo);			setCTRLButton(PAUSE_BTN, pauseVideo);			stageResize();		}				/**		*		* Sets the paused state of the video in the interface.		* @param 		* @return void		*		**/		private function setPausedState():void		{			currentState = "paused";			PAUSE_BTN.visible = false;			PLAY_BTN.visible = true;			disableCTRLButton(PAUSE_BTN, pauseVideo);			setCTRLButton(PLAY_BTN, playVideo);		}				/**			* Removes the welcome message if it exists		* @param		* @return void		*/		private function removeWelcome():void		{			if(contains(welcome)){ removeChild(welcome); }		}		/*==========  Scrubbing functionality  ==========*/				private function changeScrubState(e:MouseEvent):void		{			if(e.type == "mouseDown"){				removeWelcome();								lastState = currentState;				if(VIDEO_TYPE == "youtube") {					YouTubePlayer.pauseVideo();				}else if(VIDEO_TYPE == "vimeo"){					//vimeoPlayer.pause();				}else{					stream.pause();				}								removeEventListener(Event.ENTER_FRAME, updateScrub);							var btn:MovieClip = MovieClip(e.currentTarget);				btn.stopDragBtn.addEventListener(MouseEvent.MOUSE_MOVE, seekVideo);				btn.stopDragBtn.addEventListener(MouseEvent.MOUSE_UP, stopScrubDragging);				STAGE.addEventListener(Event.MOUSE_LEAVE, stopScrubDragging);								STAGE.addChild(btn.stopDragBtn);			}		}				private function startScrubDragging(e:MouseEvent):void		{			VIDEO_SCRUBBER.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_DOWN));			VIDEO_SCRUBBER.x = VIDEO_SCRUBBER_SC.x + (VIDEO_SCRUBBER_SC.mouseX < 0 ? 0 : (VIDEO_SCRUBBER_SC.mouseX > seekbarWidth ? seekbarWidth : VIDEO_SCRUBBER_SC.mouseX));			VIDEO_SCRUBBER.x += VIDEO_SCRUBBER_SC.mouseX > 0 ? (VIDEO_SCRUBBER_SC.mouseX < seekbarWidth ? -8 : 0) : 0;			VIDEO_SCRUBBER.y = VIDEO_SCRUBBER_SC.y;						var newSeek:* = ((VIDEO_SCRUBBER.x - VIDEO_SCRUBBER_SC.x) / seekbarWidth) * duration;			if(VIDEO_TYPE=="youtube") 			{				YouTubePlayer.seekTo(newSeek);			}			else if(VIDEO_TYPE == "vimeo")			{				//vimeoPlayer.seekTo(newSeek);			}			else			{				stream.seek(newSeek);			}		}				/**		*		* Fired when the scrub bar is let go of		* @param e:Event 		* @return void		* 		**/		private function stopScrubDragging(e:Event = null):void		{			if(!e.currentTarget) return;			var stopDragButton:MovieClip;			if(e.currentTarget is Stage)			{				if(!STAGE.contains(STAGE.getChildByName("stopDragButton"))) return;				stopDragButton = MovieClip(STAGE.getChildByName("stopDragButton"));			}			else			{				stopDragButton = MovieClip(e.currentTarget);			}						STAGE.removeEventListener(Event.MOUSE_LEAVE, stopScrubDragging);			stopDragButton.removeEventListener(MouseEvent.MOUSE_UP, stopScrubDragging);			stopDragButton.removeEventListener(MouseEvent.MOUSE_MOVE, seekVideo);						if(lastState == "playing")			{				if(VIDEO_TYPE == "youtube") 				{					YouTubePlayer.playVideo();					if(YouTubePlayer.getCurrentTime() < duration)					{						setPlayedState();					}									}				else if(VIDEO_TYPE == "vimeo")				{					/*vimeoPlayer.play();					if(vimeoPlayer.getCurrentVideoTime() < duration){						setPlayedState();					}*/									}				else				{					stream.resume();					if(stream.time < duration)					{						setPlayedState();					}				}			}									lastState = null;						VIDEO_SCRUBBER.x = VIDEO_SCRUBBER.x < VIDEO_SCRUBBER_SC.x ? VIDEO_SCRUBBER_SC.x : (VIDEO_SCRUBBER.x > VIDEO_SCRUBBER_SC.x + seekbarWidth ? VOLUME_SCRUBBER.sc.x + seekbarWidth : VIDEO_SCRUBBER.x);			VIDEO_SCRUBBER.y = VIDEO_SCRUBBER_SC.y;						addEventListener(Event.ENTER_FRAME, updateScrub);						if(STAGE.contains(stopDragButton))			{ 				STAGE.removeChild(stopDragButton); 			}		}				/**		*		* Updates the scrub bar position		* @param e:Event		* @return void		* 		**/		private var timeV:*;		private function updateScrub(e:Event = null):void		{			if(VIDEO_TYPE == "youtube") 			{				if(duration && trimOutPoint < duration && duration > 0)				{					duration = YouTubePlayer.getDuration() - trimOutPoint;				}				else				{					duration = YouTubePlayer.getDuration();				}				timeV = YouTubePlayer.getCurrentTime();			}			else if(VIDEO_TYPE == "vimeo")			{				//DEPRECATED				//duration = vimeoPlayer.getDuration();				//timeV =	vimeoPlayer.getCurrentVideoTime();			}			else			{				timeV = stream.time;			}			//Wait until the duration is valid/figured out			if(duration > 0) 			{				VIDEO_SCRUBBER.x = VIDEO_SCRUBBER_SC.x + (timeV / duration) * seekbarWidth;				//WARNING: This must initialize after the video has loaded. Otherwise, the duration will be off.				//put the trim points in position				if(!trimPointsInitialized)				{					initTrimPoints();				}			}		}	  /*==========  Volume functionality  ==========*/	  		private function changeVolumeScrubState(e:MouseEvent):void		{			if(e.type == "mouseDown")			{				addEventListener(Event.ENTER_FRAME, updateVolume);				var btn:MovieClip = MovieClip(e.currentTarget);				btn.stopDragBtn.addEventListener(MouseEvent.MOUSE_UP, stopVolumeScrubDragging);				STAGE.addEventListener(Event.MOUSE_LEAVE, stopVolumeScrubDragging);				STAGE.addChild(btn.stopDragBtn);			}		}				private function toggleMute(e:MouseEvent=null):void		{			if(VOLUME_SCRUBBER.x>0)			{				VOLUME_SCRUBBER.x = 0;				updateVolume();				setVolume(0);			}			else			{				VOLUME_SCRUBBER.x = VOLUME_BAR_BG.width-VOLUME_SCRUBBER.width;				updateVolume();				setVolume(1);			}		}						private function startVScrubDragging(e:MouseEvent):void		{			VOLUME_SCRUBBER.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_DOWN));			VOLUME_SCRUBBER.x = VOLUME_SCRUBBER.sc.x + (VOLUME_SCRUBBER.sc.mouseX < 0 ? 0 : (VOLUME_SCRUBBER.sc.mouseX > volumebarWidth ? volumebarWidth : VOLUME_SCRUBBER.sc.mouseX));			VOLUME_SCRUBBER.x += VOLUME_SCRUBBER.sc.mouseX > 0 ? (VOLUME_SCRUBBER.sc.mouseX < volumebarWidth ? -5 : 0) : 0;			VOLUME_SCRUBBER.y = VOLUME_SCRUBBER.sc.y;		}				private function stopVolumeScrubDragging(e:Event):void		{			var stopDragButton:MovieClip;						if(e.currentTarget is Stage)			{				if(!STAGE.contains(STAGE.getChildByName("stopDragButton"))) return;								stopDragButton = MovieClip(STAGE.getChildByName("stopDragButton"));			}			else			{				stopDragButton = MovieClip(e.currentTarget);			}						STAGE.removeEventListener(Event.MOUSE_LEAVE, stopVolumeScrubDragging);			stopDragButton.removeEventListener(MouseEvent.MOUSE_UP, stopVolumeScrubDragging);			removeEventListener(Event.ENTER_FRAME, updateVolume);									VOLUME_SCRUBBER.x = VOLUME_SCRUBBER.x < VOLUME_SCRUBBER.sc.x ? VOLUME_SCRUBBER.sc.x : (VOLUME_SCRUBBER.x > VOLUME_SCRUBBER.sc.x + volumebarWidth ? VOLUME_SCRUBBER.sc.x + volumebarWidth : VOLUME_SCRUBBER.x);			VOLUME_SCRUBBER.y = VOLUME_SCRUBBER.sc.y;						if(STAGE.contains(stopDragButton)){STAGE.removeChild(stopDragButton);}						sharedObj.data.volume = VOLUME_SCRUBBER.x - VOLUME_SCRUBBER.sc.x;			try			{				sharedObj.flush();			}			catch(er:Error)			{				showError("Could not write SharedObject[sharedObj] to disk! Error : " + er);			}		}		/**		* Helper method to update the volume. This also updates the interface.		*/		private function updateVolume(e:Event=null):void		{			VOLUME_BAR.width = (VOLUME_SCRUBBER.x - VOLUME_SCRUBBER_SC.x) > 0 ? ((VOLUME_SCRUBBER.x - VOLUME_SCRUBBER_SC.x) < volumebarWidth ? (ctrlBar.bar_volume_mc.scrub_mc.x - VOLUME_SCRUBBER_SC.x) : volumebarWidth) : 0.01;			setVolume((VOLUME_BAR.width / volumebarWidth));		}				/**		* Sets the volume of the video		*/		private function setVolume(v:Number):void		{			if(VIDEO_TYPE == "youtube")			{				YouTubePlayer.volume = v*100;			}			else if(VIDEO_TYPE == "vimeo")			{						}			else			{				soundtransform.volume = v;				stream.soundTransform = soundtransform;			}			}						/*==========  Button actions  ==========*/				public function setCTRLButton(btn:MovieClip, clickFun:Function = null, stateFun:Function = null):void		{			btn.buttonMode = true;			if(stateFun!= null)			{				btn.addEventListener(MouseEvent.MOUSE_OVER, stateFun);				btn.addEventListener(MouseEvent.MOUSE_OUT, stateFun);				btn.addEventListener(MouseEvent.MOUSE_DOWN, stateFun);				btn.addEventListener(MouseEvent.MOUSE_UP, stateFun);			}			else			{				setCTRLBtnOutState(btn);				btn.addEventListener(MouseEvent.MOUSE_OVER, changeCTRLButtonState);				btn.addEventListener(MouseEvent.MOUSE_OUT, changeCTRLButtonState);				btn.addEventListener(MouseEvent.CLICK, clickFun);			}		}		public function disableCTRLButton(btn:MovieClip, clickFcn:Function, stateFun:Function = null):void		{			if(stateFun!= null)			{				btn.removeEventListener(MouseEvent.MOUSE_OVER, stateFun);				btn.removeEventListener(MouseEvent.MOUSE_OUT, stateFun);				btn.removeEventListener(MouseEvent.MOUSE_DOWN, stateFun);				btn.removeEventListener(MouseEvent.MOUSE_UP, stateFun);			}			else			{				btn.removeEventListener(MouseEvent.MOUSE_OVER, changeCTRLButtonState);				btn.removeEventListener(MouseEvent.MOUSE_OUT, changeCTRLButtonState);				btn.removeEventListener(MouseEvent.CLICK, clickFcn);			}		}		private function setCTRLBtnOverState(btn:MovieClip):void		{			if(btn.getChildByName("gfx"))			{				TweenLite.to(btn.gfx, 0.5, {tint:CCVideoPlayer.btnOverColor});			}			if(btn.getChildByName("ico"))			{				TweenLite.to(btn.ico, 0.5, {tint:CCVideoPlayer.btnHighlightColor, alpha:0.8});			}		}		private function setCTRLBtnOutState(btn:MovieClip):void		{			if(btn.getChildByName("gfx"))			{				TweenLite.to(btn.gfx, 0.5, {tint:CCVideoPlayer.btnOutColor});			}			if(btn.getChildByName("ico"))			{				TweenLite.to(btn.ico, 0.5, {tint:CCVideoPlayer.btnHighlightColor, alpha:1.0});			}		}		private function changeCTRLButtonState(e:MouseEvent):void{					switch(e.type)			{				case "mouseOver":					setCTRLBtnOverState(MovieClip(e.currentTarget));					break;				default:					setCTRLBtnOutState(MovieClip(e.currentTarget));					break;			}		}						/*==========  Error Handling  ==========*/				private function showError(txt:String=""):void		{		 	MonsterDebugger.trace(this, txt);		 	ctrlBar.errortxt_mc.visible = true;			ERROR_TF.text = txt;		}		private function hideErrorTxt():void		{		 	MonsterDebugger.trace(this, "hideErrorTxt");		 	ctrlBar.errortxt_mc.visible = false;		}		 		private function securityErrorHandler(e:SecurityErrorEvent):void		{			showError("securityErrorHandler: " + e);		}				private function asyncErrorHandler(e:AsyncErrorEvent):void		{			showError("asyncErrorHandler: " + e.text);		}				private function youtubeHandleError(event:YouTubeEvent):void		{			var message:String = "";			switch(event.errorCode)			{				case YouTubeError.VIDEO_NOT_FOUND:					message = "YouTube Video not found ("+event.errorCode+")";					break;				case YouTubeError.VIDEO_NOT_ALLOWED:					message = "YouTube Video not allowed ("+event.errorCode+")";					break;				case YouTubeError.EMBEDDING_NOT_ALLOWED:					message = "YouTube Embedding not allowed ("+event.errorCode+")";					break;      				default:					message = "YouTube Error ("+event.errorCode+")";					break;			}			showError(message);		}				/*==========  YouTube Actions  ==========*/				private function youtubeHandlePlayerLoaded(event:YouTubeEvent):void		{			removeWelcome();			YouTubePlayer.cueVideoById(VIDEO_SRC,0,YouTubeVideoQuality.DEFAULT);			//TODO: Figure out why this doesn't work.			//YouTubePlayer.loadVideoByUrl(VIDEO_SRC,0);			initScrubbing();			stageResize();			if(CCVideoPlayer.autoplay == "true"){ 				playVideo();			}		}		private function youtubeHandlePlayingState(event:YouTubeEvent):void		{			switch(event.playerState)			{				case YouTubePlayingState.BUFFERING:					MonsterDebugger.trace(this, "YouTubePlayingState: BUFFERING");					//if(!contains(loader)){addChild(loader);}					break;				case YouTubePlayingState.UNSTARTED:					MonsterDebugger.trace(this, "YouTubePlayingState: UNSTARTED");					break;				case YouTubePlayingState.PLAYING:					MonsterDebugger.trace(this, "YouTubePlayingState: PLAYING");					//if(contains(loader)){removeChild(loader);}					addEventListener(Event.ENTER_FRAME, updateLoadingbar);					setPlayedState();					break;				case YouTubePlayingState.PAUSE:					MonsterDebugger.trace(this, "YouTubePlayingState: PAUSE");					setPausedState();					break;				case YouTubePlayingState.VIDEO_CUED:					MonsterDebugger.trace(this, "YouTubePlayingState: Video is cued");					break;				case YouTubePlayingState.VIDEO_ENDED:					if(CCVideoPlayer.videoLoop == "false")					{						if(lastState == null)						{							if (!contains(welcome))							{								addChildAt(welcome, getChildIndex(video_mc) + 1);								YouTubePlayer.seekTo(0);								pauseVideo();							}						}					}					else					{						YouTubePlayer.seekTo(0);						//pauseVideo();					}					break;				default:					//"uh what happens?? " + event.playerState;					break;			}			 		}		/**		*		* Returns the number of seconds from the video time		* @param duration:uint The duration of the video		* @return Number The number of seconds		**/		public function getSecs(dur:uint):uint		{			return uint(dur % 60);		}		/**		*		* Returns the number of minutes from the video time		* @param duration:Number The duration of the video		* @return Number The number of minutes		**/		public function getMins(dur:Number):uint		{			return uint(dur / 60);		}				/**		*		* Rounds to a specific number of decimal places		* @param num:Number The number to round		* @param places:Number The number of decimal places to round to		* @return Number Rounded number		**/		public function roundTo(num:Number, places:Number = 0):Number		{			if(places == 1)			{				return int((num)*10)/10;			}			else if(places == 2)			{				return int((num)*100)/100;			}			else if(places == 3)			{				return int((num)*1000)/1000;			}			else if(places == 4)			{				return int((num)*10000)/10000;			}			else			{				return Math.round(num);			}		} 	}}